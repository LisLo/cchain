package com.ismair.cchain

import com.ismair.cchain.keys.privateKeyPKCS8
import com.ismair.cchain.keys.publicKeyPKCS8
import com.ismair.cchain.model.Booking
import com.ismair.cchain.model.Confirmation
import com.ismair.cchain.model.Transfer
import com.ismair.cchain.securebase.TDB
import com.ismair.cchain.securebase.crypt.SecureBaseAESCipher
import com.ismair.cchain.securebase.crypt.SecureBaseRSACipher
import com.ismair.cchain.securebase.extensions.*
import com.ismair.cchain.securebase.functions.createSecureBaseService
import kotlinx.serialization.json.JSON
import java.util.*

val URL = "https://securebase.transbase.de:50443/REST/TDB/"
val USER = "SecureBase2017"
val PWD = "|NrBQF!ntpp'"
val tdb = createSecureBaseService(URL, USER, PWD, TDB::class.java)
var tdbSession: String? = null
var tdbExpirationDate: Date? = null

val publicKey = publicKeyPKCS8.toPublicKey()
val privateKey = privateKeyPKCS8.toPrivateKey()

fun getSession(): String {
    var session = tdbSession
    var expirationDate = tdbExpirationDate

    while (session == null || expirationDate == null || expirationDate.before(Date())) {
        println("trying to login to tdb ...")

        try {
            val pubKey = publicKeyPKCS8.encodeURIComponent()
            val randomToken = UUID.randomUUID().toString()
            val content = tdb.connect(randomToken).execute().extractObj()
            val loginToken = content.loginToken
            val signature = SecureBaseRSACipher.sign(privateKey, loginToken).encodeURIComponent()
            val content2 = tdb.login(TDB.Credentials(pubKey, loginToken, signature)).execute().extractObj()
            val calendar = Calendar.getInstance()
            calendar.add(Calendar.SECOND, content2.timeout)
            session = content2.session
            expirationDate = Date(calendar.timeInMillis)

            println("login was successful: $session until $expirationDate")
        } catch (e: Exception) {
            println("login failed with an exception: " + e.message)
        }
    }

    tdbSession = session
    tdbExpirationDate = expirationDate
    return session
}

fun main(args : Array<String>) {
    println("starting C-cash ...")

    while (true) {
        try {
            println("loading all transactions ...")

            val allTransactions = mutableListOf<Pair<String, TDB.TransactionInfoContent>>()
            val chainMap = mutableMapOf<String, String>()

            tdb.getChains(getSession()).execute().extractList().forEach {
                val chainInfos = tdb.getTransactions(getSession(), it.chain, "", "").execute().extractObj()
                if (chainInfos.count > 0) {
                    allTransactions.addAll(chainInfos.transactions.map { Pair(chainInfos.chain, it) })
                }

                val ownerCleaned = it.owner.replace(" ", "").replace("\n", "")
                if (it.description == "generated by C-cash" && !chainMap.containsKey(ownerCleaned)) {
                    chainMap.put(ownerCleaned, it.chain)
                }
            }

            println("calculating open transfers ...")

            val publicKeyPKCS8WithoutNewLine = publicKeyPKCS8.replace("\n", " ")
            val processedTransferIds = mutableSetOf<Int>()
            val openBookings = mutableListOf<Booking>()

            allTransactions
                    .filter { it.second.sender == publicKeyPKCS8WithoutNewLine && !it.second.cryptKeySender.isNullOrEmpty() }
                    .forEach {
                        try {
                            val encryptedCryptKey = SecureBaseRSACipher.decrypt(privateKey, it.second.cryptKeySender!!.replace(" ", ""))
                            val document = SecureBaseAESCipher.decrypt(encryptedCryptKey, it.second.document)
                            val confirmation = JSON.parse<Confirmation>(document)
                            processedTransferIds.add(confirmation.transferId)
                        } catch (e: Exception) {
                        }
                    }

            println("${processedTransferIds.size} transfers already processed")

            allTransactions
                    .filter { it.second.receiver == publicKeyPKCS8WithoutNewLine && !it.second.cryptKey.isNullOrEmpty() && !processedTransferIds.contains(it.second.tid) }
                    .forEach {
                        try {
                            val encryptedCryptKey = SecureBaseRSACipher.decrypt(privateKey, it.second.cryptKey!!.replace(" ", ""))
                            val document = SecureBaseAESCipher.decrypt(encryptedCryptKey, it.second.document)
                            val transfer = JSON.parse<Transfer>(document)
                            openBookings.add(Booking(it.second.tid, it.first, it.second.sender, transfer.receiver, transfer.amount, transfer.purpose))
                        } catch (e: Exception) {
                        }
                    }

            println("processing ${openBookings.size} open bookings ...")

            openBookings.forEach {
                println("processing transfer of ${it.amount} câ‚¬ with purpose ${it.purpose}")

                val receiverCleaned = it.receiver.replace(" ", "").replace("\n", "")
                if (!chainMap.containsKey(receiverCleaned)) {
                    println("chain for receiver could not be determined, skipping transfer")
                } else {
                    val confirmation1 = Confirmation(it.transferId, it.receiver, -it.amount, it.purpose)
                    val pair1 = SecureBaseAESCipher.encrypt(JSON.stringify(confirmation1))
                    val cryptKey1 = SecureBaseRSACipher.encrypt(it.sender.toPublicKey(), pair1.first)
                    val cryptKeySender1 = SecureBaseRSACipher.encrypt(publicKey, pair1.first)
                    val document1 = pair1.second
                    val signature1 = SecureBaseRSACipher.sign(privateKey, document1)

                    tdb.createNewTransaction(getSession(), TDB.Transaction(
                            it.chain,
                            publicKeyPKCS8.encodeURIComponent(),
                            it.sender.encodeURIComponent(),
                            document1.encodeURIComponent(),
                            cryptKey1.encodeURIComponent(),
                            cryptKeySender1.encodeURIComponent(),
                            signature1.encodeURIComponent())).execute()

                    val confirmation2 = Confirmation(it.transferId, it.sender, it.amount, it.purpose)
                    val pair2 = SecureBaseAESCipher.encrypt(JSON.stringify(confirmation2))
                    val cryptKey2 = SecureBaseRSACipher.encrypt(it.receiver.toPublicKey(), pair2.first)
                    val cryptKeySender2 = SecureBaseRSACipher.encrypt(publicKey, pair2.first)
                    val document2 = pair2.second
                    val signature2 = SecureBaseRSACipher.sign(privateKey, document2)

                    tdb.createNewTransaction(getSession(), TDB.Transaction(
                            chainMap[receiverCleaned]!!,
                            publicKeyPKCS8.encodeURIComponent(),
                            it.receiver.encodeURIComponent(),
                            document2.encodeURIComponent(),
                            cryptKey2.encodeURIComponent(),
                            cryptKeySender2.encodeURIComponent(),
                            signature2.encodeURIComponent())).execute()
                }
            }
        } catch (e: Exception) {
            println("an exception was thrown (${e.message}), restarting application ...")
        }
    }
}